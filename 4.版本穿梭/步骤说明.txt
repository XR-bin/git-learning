在学习git的版本穿梭功能时，如果有C语言链表的知识，就很快能理解git版本穿梭的原理了。
git的版本穿梭的原理就是移动链表的表头，被放弃的节点不会被释放，即放弃版本依然存在，但就不存在主分支上了



步骤1：我们再修复两次 test1.txt 创造出两个版本(3.0和4.0版本)，并提交到历史区(本地库)，通过 git log 可以查看到历史区
        一共有四个版本的test1.txt。

步骤2：我们再修改 test1.txt 创造出版本5.0， 但这次我们只提交到暂存区，不提交到历史区(版本库)

步骤3：      git reset --hard HEAD^  返回上一个版本(即回到3.0版本)
            git reset --hard HEAD^^ 返回上上个版本(即回到2.0版本)
        即有多少个^，就返回上多少个版本
            另一种写法
            git reset --hard HEAD~1返回上一个版本(即回到3.0版本)
            git reset --hard HEAD~2返回上上个版本(即回到2.0版本)
        即数字表示返回上多少个版本

        这里我们使用git reset --hard HEAD^来实验，使用后再用git log 和 git status
        会发现表头变成了版本3.0，并且暂存区被清空了

步骤4：我们可以通过 git reflog 查看到我们所有版本的操作以及版本地址编号，可以查到被抛弃的版本的地址
        这里可以证明这句话 “被放弃的节点不会被释放，即放弃版本依然存在，但就不存在主分支上了” 

步骤5：既然知道里被废弃版本的地址，那么我们就可以通过 
                git reset --hard 地址
        回到被抛弃的版本，也可以通过这个方式跳到某个版本

步骤6：git reset --hard 是直接把旧版本代码推到工作区，并且把暂存区数据清除。
      但如果我们已经完成A功能了，正在开发B功能，突然发现A功能有问题，这个时候，我们需要修改A功能，
      这个时候，我们不可能把旧版本代码推回工作区，这样会影响B功能开发，又不想专门给修A功能bug开个
      版本，那就可以和B功能一起合并提交

      这个时候我们就得用 git reset --soft 把旧代码推回暂存区，工作区代码不改变，修改好A功能后跟B功能一起
      提交。

      git reset --soft HEAD^          返回上一个版本到暂存区
      git reset --soft HEAD~1         返回上一个版本到暂存区
      git reset --soft 版本3地址       返回上一个版本到暂存区

      例子：修改 test1.txt 写入A功能完成，创造出版本5.0，然后在git1文件夹中创建test2.txt，表示新功能B，并创建
            B功能版本1.0.
            发现A功能有问题，通过git reset --soft HEAD^将A功能5.0版本推回暂存区，并在工作区修改A功能，最后与B功能
            版本合并一起提交



